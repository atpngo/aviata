% James Tseng
% UAS@UCLA NASA USRC- AVIATA
% Canted Motors Thrust Vectors on F550

clear; close all; clc;

%% Parameters/Assumptions
% 0deg is forward
% coordinates x = 0deg, y = 90deg, z = pointing upward from drone

%Rotate Drone Position
Rote = pi*0; %radians
Cant = pi/12; %radians for cant angle

f = 1; % amount of throttle

RT = 1; %render type

switch(RT)
    case 1
        % Max
        F1 = 1*f;   F3 = 1*f;   F6 = 1*f;
        F2 = 1*f;   F4 = 1*f;   F5 = 1*f;
    case 2
        % Spin
        F1 = 0.75*f;   F3 = 0.75*f;   F6 = 0.75*f;
        F2 = 0.25*f;   F4 = 0.25*f;   F5 = 0.25*f;
    case 3
        % Forward
        F1 = 0.8*f;   F3 = 0.35*f;   F6 = 0.35*f;
        F2 = 0.8*f;   F4 = 0.35*f;   F5 = 0.35*f;
end

% Constants
Ct = 6.295; % motor max thrust N
Cm = 0.05; % Ct * Cm, torque generated by a single rotor at max power N*m
Md = 1.769; % mass of drone kg
Ra = 0.550 / 2; % distance of each rotor from the center the drone m



%% F550 Hexcopter

% Modeling based on "Agile Plate Transport with a Hexacopter with Canted
% Motors" - Gabriel Bousquet, Jesús Tordesillas Torres, Brett Lopez
% http://acl.mit.edu/projects/hexacopter-agile-plate-transport

% Motor Numbering
% https://docs.px4.io/master/en/airframes/airframe_reference.html#hexarotor-x
% CW:  1, 3, 6
% CCW: 2, 4, 5

%angle for each arm relative to foward
Ang = [ 3*pi/2 pi/2 pi/6 7*pi/6 11*pi/6 5*pi/6];
% Drone Rotation
Ang = Ang + Rote;

% unit distance 1 away
R = [ cos(Ang(1)) cos(Ang(2)) cos(Ang(3)) cos(Ang(4)) cos(Ang(5)) cos(Ang(6)) ;
      sin(Ang(1)) sin(Ang(2)) sin(Ang(3)) sin(Ang(4)) sin(Ang(5)) sin(Ang(6)) ;
     0 0 0 0 0 0];
% Arm Distance
R = R * Ra;
 
% Drone Center
 OG = [0 0 0];
 OGC = [ OG(1)*ones([1 6]); OG(2)*ones([1 6]); OG(3)*ones([1 6])];
 Rc = R + OGC;
 
%Color Code
 Black = [ R(:,1:2) R(:,4) R(:,6) ];
 Red = [ R(:,3) R(:,5) ];
 

%  figure(1);
%  hold on;
%  quiver3(OGC(1,1:4),OGC(2,1:4),OGC(3,1:4),Black(1,:),Black(2,:),Black(3,:), 0, 'sk');
%  quiver3(OGC(1,1:2),OGC(2,1:2),OGC(3,1:2),Red(1,:),Red(2,:),Red(3,:), 0, 'sr');
%  xlabel('x');   ylabel('y');    zlabel('z');    grid on;
%  view(3);

    
%% Canted Motors
% Perpendicular Angle
PerpAng = [ (Ang(1)+pi/2) (Ang(2)-pi/2) (Ang(3)+pi/2) (Ang(4)-pi/2) (Ang(5)-pi/2) (Ang(6)+pi/2) ];

% Cant Vectors
Cconst = [ cos(PerpAng(1))*sin(Cant) cos(PerpAng(2))*sin(Cant) cos(PerpAng(3))*sin(Cant) cos(PerpAng(4))*sin(Cant) cos(PerpAng(5))*sin(Cant) cos(PerpAng(6))*sin(Cant) ;
      sin(PerpAng(1))*sin(Cant) sin(PerpAng(2))*sin(Cant) sin(PerpAng(3))*sin(Cant) sin(PerpAng(4))*sin(Cant) sin(PerpAng(5))*sin(Cant) sin(PerpAng(6))*sin(Cant) ;
      cos(Cant) cos(Cant) cos(Cant) cos(Cant) cos(Cant) cos(Cant) ];
  % rows [x; y; z]

% Forces
C = Cconst .* [ F1 F2 F3 F4 F5 F6] * Ct;


% Torque by Prop
% CW:  1, 3, 6
% CCW: 2, 4, 5
Mp = C .* [ -1 1 -1 1 1 -1] * Cm;

% Rotation color code
Rcw = [Rc(:,1), Rc(:,3), Rc(:,6)];
Rccw = [Rc(:,2), Rc(:,4), Rc(:,5)];
Ccw = [C(:,1), C(:,3), C(:,6)];
Cccw = [C(:,2), C(:,4), C(:,5)];
  
figure(2); cla; view(3);
 hold on;
 quiver3(OGC(1,1:4),OGC(2,1:4),OGC(3,1:4),Black(1,:),Black(2,:),Black(3,:), 1, 'sk');
 quiver3(OGC(1,1:2),OGC(2,1:2),OGC(3,1:2),Red(1,:),Red(2,:),Red(3,:), 1, 'sr');
 
 %mark the motor #
 text(Rc(1,:),Rc(2,:),Rc(3,:)-0.05,['1'; '2'; '3'; '4'; '5'; '6']);
 
 quiver3(Rcw(1,:),Rcw(2,:),Rcw(3,:),Ccw(1,:)/12,Ccw(2,:)/12,Ccw(3,:)/12,0, 'g');
 quiver3(Rccw(1,:),Rccw(2,:),Rccw(3,:),Cccw(1,:)/12,Cccw(2,:)/12,Cccw(3,:)/12,0, 'b');

 switch (RT)
     case 1
         title('Maximum Thrust');
     case 2
         title('Rotation Moment');
     case 3
         title('Forward Direction');
     otherwise
         title(horzcat('Canted Angle: ', num2str(Cant/pi*180,'%2.0f'), '°'));
 end
 
 xlabel('x (m)');   ylabel('y (m)');    zlabel('z (m)');     grid on;    axis equal;
 xlim([OG(1)-0.3, OG(1)+0.3]); ylim([OG(2)-0.3, OG(2)+0.3]); zlim([OG(3)-0.1, OG(3)+0.5]);  
 
 
 %% Force Summation
 
 Fx = sum(C(1,:)); 
 Fy = sum(C(2,:)); 
 Fz = sum(C(3,:))- Md*9.8; % Weight downwards
 
figure(2);
 FSx = quiver3(OG(1),OG(2),OG(3),Fx/6, 0, 0, 1, 'cyan');
 FSx.DisplayName = horzcat('Fx: ', num2str(Fx,'% +2.3f N'));
 FSy = quiver3(OG(1),OG(2),OG(3),0,  Fy/6, 0, 1, 'cyan');
 FSy.DisplayName = horzcat('Fy: ', num2str(Fy,'% +2.3f N'));
 FSz = quiver3(OG(1),OG(2),OG(3),0, 0, Fz/6, 1, 'cyan');
 FSz.DisplayName = horzcat('Fz: ', num2str(Fz,'% +2.3f N'));

 
 drawnow;   
 hold off;

 legend([FSx, FSy, FSz], 'Location', 'northeast', 'FontName', 'FixedWidth');
 
 %% Moments
 % Currently does not consider propellor/motor torque
 M = cross(R(:,1),C(:,1)) + cross(R(:,2),C(:,2)) + cross(R(:,3),C(:,3)) + cross(R(:,4),C(:,4)) + cross(R(:,5),C(:,5)) + cross(R(:,6),C(:,6));
 
 % Prop Torque
 M = M + sum(Mp,2);
 
figure(2);
dim = [0.05 0.0 0.2 0.3];
str = {'Moments (N*m)', num2str(M(1),'X= %+2.4f'), num2str(M(2),'Y= %+2.4f'), num2str(M(3),'Z= %+2.4f')};
ah = annotation('textbox',dim,'String',str,'FitBoxToText','on'); 
ah.BackgroundColor = 'White';
ah.FontName = 'FixedWidth';


